// Generated by CoffeeScript 1.8.0
var Stats, bxd_only;

Stats = (function() {
  function Stats(the_values) {
    this.the_values = the_values;
  }

  Stats.prototype.add_value = function(value) {
    return this.the_values.push(value);
  };

  Stats.prototype.n_of_samples = function() {
    return this.the_values.length;
  };

  Stats.prototype.sum = function() {
    var total, value, _i, _len, _ref;
    total = 0;
    _ref = this.the_values;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      value = _ref[_i];
      total += value;
    }
    return total;
  };

  Stats.prototype.mean = function() {
    return this.sum() / this.n_of_samples();
  };

  Stats.prototype.median = function() {
    var is_odd, median_position, the_values_sorted;
    is_odd = this.the_values.length % 2;
    median_position = Math.floor(this.the_values.length / 2);
    let the_vals = [...this.the_values] // To prevent this.the_values from being sorted; there might be a better way to do this
    the_values_sorted = the_vals.sort(function(a, b) {
      return a - b;
    });
    if (is_odd) {
      return the_values_sorted[median_position];
    } else {
      return (the_values_sorted[median_position] + the_values_sorted[median_position - 1]) / 2;
    }
  };

  Stats.prototype.std_dev = function() {
    var step_a, step_b, sum, value, _i, _len, _ref;
    sum = 0;
    _ref = this.the_values;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      value = _ref[_i];
      step_a = Math.pow(value - this.mean(), 2);
      sum += step_a;
    }
    step_b = sum / this.the_values.length;
    return Math.sqrt(step_b);
  };

  Stats.prototype.std_error = function() {
    return this.std_dev() / Math.sqrt(this.n_of_samples());
  };

  Stats.prototype.min = function() {
    return Math.min.apply(Math, this.the_values);
  };

  Stats.prototype.max = function() {
    return Math.max.apply(Math, this.the_values);
  };

  Stats.prototype.range = function() {
    if (js_data.dataset_type == "ProbeSet"){
      if (js_data.data_scale == "linear_positive"){
        return Math.log2(this.max()) - Math.log2(this.min());
      } else {
        return this.max() - this.min()
      }
    } else {
      return this.max() - this.min()
    }
  };

  Stats.prototype.range_fold = function() {
    if (js_data.dataset_type == "ProbeSet"){
      return Math.pow(2, this.range());
    } else {
      return this.range()
    }
  };

  Stats.prototype.interquartile = function() {
    var iq, length, q1, q3;
    length = this.the_values.length;
    if (js_data.dataset_type == "ProbeSet" && js_data.data_scale == "linear_positive") {
      q1 = Math.log2(this.the_values[Math.floor(length * .25)]);
      q3 = Math.log2(this.the_values[Math.floor(length * .75)]);
    } else {
      q1 = this.the_values[Math.floor(length * .25)];
      q3 = this.the_values[Math.floor(length * .75)];
    }
    iq = q3 - q1;
    if (js_data.dataset_type == "ProbeSet") {
        return Math.pow(2, iq);
    } else {
        return iq;
    }
  };

  Stats.prototype.skewness = function() {
    var len = this.the_values.length,
        delta = 0,
        delta_n = 0,
        term1 = 0,
        N = 0,
        mean = 0,
        M2 = 0,
        M3 = 0,
        g;

    for ( var i = 0; i < len; i++ ) {
      N += 1;

      delta = this.the_values[ i ] - mean;
      delta_n = delta / N;

      term1 = delta * delta_n * (N-1);

      M3 += term1*delta_n*(N-2) - 3*delta_n*M2;
      M2 += term1;
      mean += delta_n;
    }
    // Calculate the population skewness:
    g = Math.sqrt( N )*M3 / Math.pow( M2, 3/2 );

    // Return the corrected sample skewness:
    return Math.sqrt( N*(N-1))*g / (N-2);
  };

  Stats.prototype.kurtosis = function() {
    var len = this.the_values.length,
        delta = 0,
        delta_n = 0,
        delta_n2 = 0,
        term1 = 0,
        N = 0,
        mean = 0,
        M2 = 0,
        M3 = 0,
        M4 = 0,
        g;

    for ( var i = 0; i < len; i++ ) {
      N += 1;

      delta = this.the_values[ i ] - mean;
      delta_n = delta / N;
      delta_n2 = delta_n * delta_n;

      term1 = delta * delta_n * (N-1);

      M4 += term1*delta_n2*(N*N - 3*N + 3) + 6*delta_n2*M2 - 4*delta_n*M3;
      M3 += term1*delta_n*(N-2) - 3*delta_n*M2;
      M2 += term1;
      mean += delta_n;
    }
    // Calculate the population excess kurtosis:
    g = N*M4 / (M2*M2) - 3;
    //Return the corrected sample excess kurtosis:
    return (N-1) / ( (N-2)*(N-3) ) * ( (N+1)*g + 6 );
  };

  return Stats;

})();

window.Stats = Stats;
